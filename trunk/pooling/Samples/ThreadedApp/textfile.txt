Taking
a
Dip
By
Jason
Southwell
Server
development
can
certainly
be
a
tricky
beast
Whether
you
build
web
servers
to
host
the
next
great
auction
site
or
just
need
to
develop
a
middleware
solution
as
the
backbone
of
a
new
enterprise
accounting
package
server
side
development
surely
has
it's
unique
requirements
You
most
likely
will
have
to
deal
with
things
like
multi-threading
multi-users
statelessness
and
of
course
scalability
Scalability
is
one
of
those
scary
words
you
hear
now
and
then
probably
from
your
product
sales
person
as
he
peeks
in
to
relay
a
customer
question
Often
in
response
you
may
make
up
some
story
designed
to
cleverly
talk
your
way
around
the
issue
This
is
all
fine
until
that
one
terribly
foreboding
day
in
the
future
when
the
application
is
actually
deployed
in
a
high
traffic
environment
Will
it
stand
up
to
the
test
Will
it
hold
out
strong
Or
will
it
crash
and
burn
along
with
the
end
of
year
bonus
you
were
hoping
for

The
question
can
at
times
be
enough
to
cause
ulcers
in
the
calmest
of
stomaches
If
you
develop
server
applications
and
have
had
concerns
about
your
application's
scalability
then
I
encourage
you
to
read
further

However
if
you
develop
server
applications
and
have
never
had
concerns
about
your
application's
scalability
then
you
have
a
drastically
limited
audience
are
already
a
master
of
application
design
or
you
are
already
a
master
of
self
delusion

I'll
leave
it
for
you
to
decide
which
So
what
can
be
done
to
improve
an
application's
scalability

That
is
a
question
not
so
easily
answered
without
specific
knowledge
of
the
application

Depending
on
the
bottleneck
sometimes
a
simple
tweak
here
and
there
is
enough
to
fix
the
problem

However
the
problem
may
also
be
at
the
core
of
the
application's
design

In
this
case
the
only
answer
may
be
to
stop
everything
take
a
few
deep
breaths
and
start
from
the
beginning

As
a
complete
examination
of
all
potential
bottlenecks
is
not
possible
in
this
article
I
hope
to
give
you
a
couple
of
hints
toward
that
goal
by
using
a
technique
I've
written
a
about
in
the
past

I'm
talking
about
pooling

In
this
article
I
hope
to
present
a
good
overview
of
what
can
be
solved
with
pooling
and
when
implementing
it
makes
the
most
sense

To
help
us
implementing
pooling
in
the
future
we'll
also
build
a
common
class
for
us
to
reuse
in
our
pooling
efforts
Basic
Concepts
Pooling
at
it's
core
is
a
set
number
of
pre-created
and
pre-configured
objects
stored
in
a
global
list

Preparing
this
list
of
objects
allows
you
to
immediately
obtain
access
to
these
objects
as
needed
at
runtime

This
allows
for
reduced
execution
and
transaction
time
and
yields
more
potential
scalability

So
what
types
of
objects
can
be
pooled

Pretty
much
anything


In
a
previous
issue
of
“The
Delphi
Magazine”
I
wrote
about
database
connection
pooling

In
that
case
we
were
talking
specifically
about
pooling
database
objects
for
connecting
to
Interbase

However
even
applications
with
no
database
requirements
can
make
effective
use
of
pooling

Pooling
can
also
speed
access
to
things
like
COM
connections
TCP
connections
and
even
base
delphi
classes
such
as
sorted
TStringLists

Pretty
much
anything
can
be
pre-created
and
pre-configured
for
later
immediate
access
Calculating
the
Benefits
Before
you
jump
into
any
optimization
it
benefits
you
to
understand
exactly
where
your
performance
bottlenecks
are

It
is
easy
to
make
assumptions
and
spend
days
or
even
months
working
on
something
that
in
the
end
won't
make
any
difference

For
example
database
pooling
almost
always
improves
your
performance
however
there
are
cases
where
pooling
them
might
not
help

When
connecting
to
some
database
technologies
such
as
local
disk
file
or
embedded
database
technologies
speed
is
often
more
closely
related
with
disk
access
speed
than
network
and
external
server
speeds

This
type
of
access
is
generally
fast
enough
that
there
is
almost
no
time
savings
in
pre-configuration
these
database
connections

Therefore
to
increase
response
time
in
these
circumstances
memory
pooling
of
cached
data
might
be
a
preferred
use
of
pooling
rather
than
pooling
the
database
connections
themselves

It
also
may
be
that
your
database
connection
is
in
fact
a
bottleneck
however
it
is
relatively
minor
in
the
scope
of
your
entire
application

There
may
be
other
bottlenecks
more
pertinent
to
the
cause
of
your
scalability
problems
and
time
would
be
best
spent
working
on
those
There
are
several
methods
to
help
discover
your
application's
bottlenecks

A
good
profiling
application
can
certainly
help
but
there
are
methods
to
use
that
don't
require
spending
big
money

Included
in
the
source
code
on
this
disk
is
uProfilerpas

This
unit
houses
functions
which
I
make
use
of
when
profiling
routines

It
may
be
helpful
to
wrap
these
functions
around
questionable
sections
of
code
to
see
where
the
majority
of
your
time
is
spent
When
talking
about
scalability
it
helps
to
remember
that
there
are
really
two
main
areas
for
which
you
need
to
account

The
first
as
we've
talked
about
is
response
time

In
addition
to
that
you
must
also
watch
your
web
application's
memory
usage
Let's
examine
how
pooling
effects
your
application's
memory
usage

In
general
pooling
objects
will
improve
execution
time
while
at
the
same
time
maintaining
a
fairly
static
memory
usage

By
this
I
mean
that
when
you
only
have
a
few
concurrent
connections
pooling
will
have
a
higher
memory
usage
requirement
than
when
creating
objects
only
as
needed

However
as
the
number
of
concurrent
connections
grow
the
memory
requirements
do
not

Just
as
the
size
of
the
pool
remains
the
same
so
does
the
memory
used
by
the
pool

Knowing
this
gives
us
another
potential
use
for
pooling

Examine
your
application
closely
for
areas
where
you
load
or
create
common
data
for
each
concurrent
user

In
these
cases
it
may
make
sense
to
pool
that
common
data
requesting
it
from
the
pool
as
needed

And
though
I
mentioned
before
that
local
databases
often
see
little
speed
improvements
through
pooling
you
may
see
massive
memory
improvements

Using
pooling
in
this
way
will
keep
the
memory
usage
requirements
much
more
stable
for
your
application

Also
included
in
the
uProfilerpas
file
is
a
function
to
test
application
memory

When
you
are
profiling
your
application
it
may
be
a
good
idea
to
check
this
value
at
deliberate
areas
of
your
application
often
after
each
connection

If
you
see
a
steady
increase
in
memory
usage
related
to
creation
of
these
objects
pooling
may
help
A
Generic
Pooling
Implementation
You
may
remember
the
Interbase
pooling
component
I
included
with
my
aforementioned
article

While
it
was
good
for
what
it
was
written
for
it
offered
little
help
to
those
who
wanted
to
pool
anything
else

Since
then
I've
also
released
a
TDataModule
pooling
component
to
OpenSource
in
order
to
assist
with
a
more
generic
connection
pooling

If
you
would
like
to
have
a
look
at
that
component
it
is
available
for
free
at
wwwarcanatechcom

Since
developing
these
components
I've
have
found
other
great
uses
for
pooling

Even
basic
Delphi
classes
such
as
sorted
string
lists
can
be
used
and
reused
within
server
applications

To
accommodate
this
I
thought
it
might
be
handy
to
build
a
base
pool
class
to
pool
objects
of
any
type

Later
as
you
need
this
pool
class
can
be
subclassed
to
create
pools
for
nearly
any
Delphi
class
At
a
minimum
we
will
need
a
list
of
objects
created
and
stored
in
memory

We
will
also
need
a
thread
safe
acquisition/release
process
and
a
method
of
determining
which
objects
are
currently
in
use

To
accomplish
some
of
this
we
will
borrow
some
techniques
from
both
the
Interbase
pooling
component
and
the
TDataModulePool
component
I
mentioned
previously
We
will
use
a
TList
to
store
our
list
of
objects
in
memory

We
could
optionally
use
a
TThreadList
however
in
our
case
we
will
be
implementing
our
own
thread
protection
so
it
isn't
really
needed

Also
use
of
a
TThreadList
really
shines
when
you
will
be
adding
to
a
list
more
often
than
reading
from
it

In
our
case
all
objects
will
be
created
and
added
to
the
list
before
any
reading
occurs

For
these
reasons
a
TList
makes
the
most
sense

In
the
past
I
have
used
the
terminology
Lock
and
Unlock
to
describe
the
acquire
and
release
process
of
an
object
however
this
is
probably
a
misnomer

In
this
implementation
I
instead
decided
to
call
the
process
Acquire
and
Release
as
this
is
more
descriptive
of
what
you
are
truly
doing

When
you
acquire
an
object
it
does
in
fact
lock
that
object
from
being
used
in
another
thread
but
since
the
calling
process
actually
receives
the
instance
of
the
object
until
it
is
finished
with
it
I
think
acquire
and
release
sounds
more
accurate
Listing
1
shows
the
type
declaration
of
our
new
class
We
need
way
to
know
that
an
object
is
currently
in
use
by
a
thread


This
could
be
accomplished
many
different
ways

I've
found
the
TBits
class
to
be
the
most
memory
efficient
and
best
performing
method

TBits
is
essentially
an
array
of
boolean
values
wrapped
into
a
class

So
why
don't
we
just
use
an
array
of
boolean
values

TBits
maintains
it's
list
using
boolean
logic
on
an
array
of
integers
which
is
very
efficient

It
also
provides
a
handy
method
OpenBit
which
locates
the
first
item
in
the
array
with
a
false
value
which
allows
us
to
quickly
locate
an
available
object
in
the
pool

The
only
problem
is
that
TBits
is
not
a
thread
safe
class

It
would
be
disastrous
to
accidentally
give
the
same
object
to
two
different
threads
therefore
we
will
be
wrapping
all
access
to
this
class
in
a
critical
section
Thanks
to
TBits
acquiring
objects
from
the
pool
is
fairly
straightforward

Essentially
an
available
object
must
be
found
via
the
TBitsOpenBit
method
(see
Listing
2)

That
object
must
then
be
marked
as
used
and
returned
to
the
user

When
the
user
is
done
the
user
must
release
the
object
back
into
the
pool

At
that
time
we
mark
the
object
as
not
in
use
in
our
TBits
class
so
that
it
will
be
ready
for
the
next
user
This
seems
like
an
appropriate
time
to
discuss
a
potential
problem

What
should
happen
when
you
call
the
acquire
method
but
no
objects
are
available

There
are
a
few
different
approaches
you
can
take

First
and
probably
the
safest
for
the
health
of
your
server
is
to
deny
the
object
and
raise
an
error
to
the
user

This
of
course
has
the
side
effect
of
an
error
message
being
shown
to
the
client
which
must
then
take
action
to
resubmit
the
request

However
if
you
also
are
writing
the
client
application
you
may
be
able
to
trap
this
error
and
resubmit
the
request
automatically

This
solution
is
by
far
the
safest
from
a
server
stability
standpoint

This
is
because
an
error
response
is
immediate
no
additional
memory
or
processing
is
required
Next
is
the
approach
I
took
in
the
original
Interbase
pooling
components
mentioned
earlier
queuing

In
this
method
a
request
is
added
to
a
queue
which
waits
for
an
object

to
become
available

This
method
is
fine
when
you
are
positive
that
the
object
will
not
become
permanently
locked
by
accident

When
this
happens
you
can
quickly
run
out
of
resources
as
requests
are

permanently
locked
waiting
for
objects
which
will
never
become
available

All
this
time
more
and
more
requests
arrive
which
eventually
drag
the
system
to
a
halt

You
must
also
consider
the
potential
for
hacker
type
attacks

A
Denial-Of-Service
(DOS)
attack
is
one
where
a
hacker
will
continually
hit
your
application
with
requests
until
it
is
overloaded
and
crashes

DOS
attacks
can
destroy
a
queued
system

When
requests
are
coming
in
faster
than
they
can
be
processed
the
size
of
the
queue
keeps
growing
until
the
application
crashes

Implementing
a
maximum
queue
size
can
help
limit
these
sorts
of
problems
but
then
you
must
return
an
rror
to
the
user
anyway
Lastly
is
the
solution
that
is
most
requested
from
users
of
the
current
TDataModulePool
component

That
is
to
automatically
increase
the
size
of
the
pool
as
needed
when
the
maximum
is
reached

This
is
far
from
optimal
as
you
still
have
the
same
potential
problems
as
a
queued
system
except
perhaps
to
worse
ends
Pooled
objects
are
often
pooled
because
they
are
fairly
heavyweight
and
therefore
pooled
objects
use
resources
faster
than
queued
request
objects

The
best
solution
is
probably
a
combination
of
the
three
methods

Regardless
due
to
popular
demand
we
will
use
the
final
mentioned
method
for
our
pool
implementation
with
the
addition
of
a
maximum
pool
size

Since
for
safety
reasons
you
may
decide
not
to
allow
this
for
your
application
we
will
also
implement
an
AutoGrow
property
allowing
the
final
developer
to
disable
this
feature
Lastly
we
must
discuss
how
to
add
items
to
our
pool

At
first
glance
it
would
seem
best
to
include
an
AddObject
method

Unfortunately
this
wont
work
as
the
pool
itself
must
dynamically
expand
and
shrink

This
means
that
the
pool
must
dictate
when
it
is
time
to
create
and
destroy
an
object

We
could
just
allow
the
pool
to
internally
create
the
objects
for
us
but
doing
this
ties
the
pool
to
a
specific
class
type

So
instead
we'll
use
events
for
both
creation
and
destruction
of
objects

It
isn't
often
you
see
events
on
objects
other
than
components
but
they
seem
to
make
the
most
sense
in
this
case
Using
the
Pool
Class
For
the
purposes
of
a
quick
example
I've
created
a
simple
multithreaded
application
that
loads
a
text
file
into
a
pool
of
sorted
TStringLists

Each
thread
randomly
pulls
words
from
the
list
using
the
built
in
TStringList
quicksort
algorithms

Listing
3
shows
the
code
which
initializes
the
pool
with
TStringList
objects

Calling
the
Start
method
causes
the
OnCreateObject
event
to
be
called

In
this
event
we
will
create
each
list
and
load
it
with
sorted
text

Listing
4
shows
the
thread
execute
method
from
the
sample
application
where
a
TStringList
object
is
acquired
from
the
pool

You
will
see
that
in
order
to
more
closely
mimic
actual
server
traffic
random
delays
are
added
between
thread
executions

Of
course
you
would
not
do
this
in
a
normal
application
Conclusion
Pooling
can
be
an
effective
tool
in
extending
the
scalability
of

your
multithreaded
applications

While
I
urge
you
to
actively
search
for
ways
to
implement
this
and
other
methods
of
improving
scalability
you
should
first
learn
if
it
makes
sense
to
do
so

Profile
your
applications
looking
for
the
source
of
each
bottleneck

If
the
problem
is
connection
related
or
if
you
have
common
data
copied
across
multiple
users
pooling
may
be
the
answer
